# GitWorkFlow





### 1.Centralized workflow  
팀 구성원은 중앙저장소를 clone(복제)하여 로컬저장소를 만든 후, 로컬저장소에서 개발하고 파일을 수정하여 커밋(commit)한다.
철수와 영희 2명이 개발을 시작한다. 철수와 영희 둘 중 한명은 중앙저장소를 생성한다. 그리고 철수와 영희 모두 `git clone` 명령어로 중앙저장소를 복제해서 로컬 저장소를 생성한다. 파일을 수정하여 중앙저장소가 아닌 로컬저장소에 커밋하는 것이므로, 중앙저장소의 변경내역을 신경쓸 필요없이 몇번이고 수정과 커밋을 할 수 있다.
그리고 자신의 커밋이력을 중앙저장소에 올려 공유하려 한다면 `git push origin master`명령어를 이용한다. 이 명령어의 뜻은 로컬의 master브랜치를 origin(중앙저장소를 복제할 때 자동 생성된 별칭, 로컬 저장소와 중앙저장소를 연결)의 master브랜치에 동기화 하겠다는 뜻이다. 현재 아무도 중앙저장소에 push한 적이 없으므로 작업은 순조롭다.
문제는 다른 한명이 push를 할 때 발생한다. 나중에 commit을 하는 사람을 영희라고 가정할 때, 영희의 commit 이력은 중앙저장소의 최신 이력을 포함하고 있지 않기 때문에 에러가 발생한다. 이것은 중앙 저장소의 commit 이력을 보호하기 위함이다. 따라서 이 문제를 해결하는 방법은 `git pull`명령으로 중앙 저장소의 변경이력을 자신의 로컬저장소로 내려 받은 후, git add/commit 작업을 다시 해주고 진행하는 방법으로 해결한다. 
여기서 잠시 멈추고 공부를 정리해야 할 것이 있다. `git pull`명령은 중앙저장소의 최신 이력을 내려받는 동작(fetch)과 이를 로컬 이력과 합치는 동작(merge)을 한번에 한다. 또한 push작업시에 --rebase(재배열) 명령어를 주면 불필요하게 git add/commit 작업을 다시 해줄 필요없이 git pull 해온 중앙저장소의 변경이력을 영희의 commit 이력 앞에 끼워 넣는다. 

장점. svn과다르게 로컬에서도 커밋할수있다는점. 즉 네트워크가 필요없다는 것 
단점. 중앙저장소를 최신으로 유지하기위해선 매번 pull해와서 다시 push해줘야함. 


### 2.Feature Branch Workflow

Feature Branch Workflow의 핵심 컨셉은 기능별 브랜치를 만들어서 작업한다는 사실이다. 기능 개발 브랜치는 격리된 작업 환경을 제공하기 때문에 다수의 팀 구성원이 메인 코드 베이스(master)를 중심으로 해서 안전하게 새로운 기능을 개발할 수 있다. 이 워크플로우도 프로젝트의 공식적인 변경 이력을 기록하기 위해서 중앙 저장소와 master 브랜치를 사용한다. 그런데, master 브랜치에 직접 커밋하지는 않고, 새로운 기능을 개발할 때마다 브랜치를 만들어서 작업한다. 보통 animated-menu-items 또는 issue-#1061처럼 의미를 담고 있는 브랜치 이름을 사용한다.
브랜치를 이용하면 격리된 영역에서 안전하게 새 기능을 개발할 수 있을 뿐만아니라, master 브랜치를 손대지 않기 때문에 다른 기능 개발 브랜치를 얼마든지 올려도 된다. 이는 일종의 로컬 저장소 백업 역할을 하기도 한다. 
Feature Branch Workflow의 또다른 장점 중의 하나가 바로 `풀 리퀘스트`이다. `풀 리퀘스트`란 기능 개발을 끝내고 master에 바로 병합하는 것이 아니라, 브랜치를 중앙 저장소에 올리고 master에 병합(merge)해달라고 요청하는 것이다. 이것의 이점은 팀 구성원들과 개발 내용에 대한 의견(코드 리뷰 등)을 나눌 수 있다는 점이다. 예를 들어 주니어 개발자가 업무지시를 받고 어떤 기능에 대한 브랜치를 구현하였다고 하자. 주니어 개발자는 이것을 중앙 저장소에 push하고 팀 구성원들에게 `풀 리퀘스트`를 보낸다. 그러면 팀 구성원들은 해당 코드를 리뷰하고, 수정할 점이나 개선점에 대한 조언을 받을 수 있을 것이다. 또한 이것은 꼭 해당 기능 브랜치가 완성되어야만 보내는 것도 아니다. 따라서 개발 중 막히는 부분이 있을 때, 풀 리퀘스트를 보내서 시니어 개발자에게 개발 방향에 대한 조언도 얻을 수 있을 것이다. 이것은 다른 팀 구성원이 나의 작업내용과 진도를 확인할 수 있는 이점이 있고 팀 구성원간에 변경 내용에 대한 소통을 촉진하여 코드 품질을 높이는 부수 효과도 있다.

장점 기능별 개발로 인해 마스터 브랜치가 안전하다. 풀리퀘스트로 인해 팀구성원간의 소통을 촉진하고, 코드품질을 높일 수 있다.
단점  유연성은 큰 장점이지만, 현장에서 적용할 때 유연성은 독이 될 수도 있다. 특히 팀이 크고, 프로젝트 규모가 크면 브랜치마다 좀 더 특별한 의미를 부여하는 것이 더 낫다. 


### 3. Gitflow Workflow

Feature Branch Workflow보다 복잡하긴하지만, 장점이자 단점이었던 유연성을 대형 프로젝트에도 적용할 수 있는 Workflow이다. Gitflow Workflow도 팀 구성원간의 협업을 위한 창구로 중앙 저장소를 사용한다. 로컬 브랜치에서 작업하고 중앙 저장소에 푸시한다. 단지 브랜치의 구조만 다를 뿐이다.

이 워크플로우의 모든 작업 절차들은 master와 develop 두 개의 브랜치를 대상으로 한다.
새로운 기능은 각각의 브랜치에서 개발하고 백업 및 협업을 위해서 중앙 저장소에 푸시한다. 그런데, master 브랜치에서 기능 개발을 위한 브랜치를 따는 것이 아니라, develop 브랜치에서 딴다. 그리고, 기능 개발이 끝나면 다시 develop 브랜치에 작업 내용을 병합한다. 바꾸어 말하면, 기능 개발을 위한 브랜치는 master 브랜치와는 어떤 상호 작용도 하지 않는다.



develop 브랜치에 릴리스(release 풀어주다)를 할 수 있는 수준만큼 기능이 모이면(또는 정해진 릴리스 일정이 되면), develop 브랜치를 기준으로 릴리스를 위한 브랜치를 딴다. 


이 브랜치를 만드는 순간부터 릴리스 사이클이 시작되고, 버그 수정, 문서 추가 등 릴리스와 직접적으로 관련된 작업들을 제외하고는 이 브랜치에 새로운 기능을 추가 병합하지 않는다. 릴리스 준비가 완료되면 master 브랜치에 병합하고 버전 태그를 부여한다. 이 말의 뜻은 이제 master 브랜치가 애플리케이션 버전 1.0이라는 의미이다.
그리고, 릴리스를 준비하는 동안 develop 브랜치가 변경되었을 수 있으므로 develop 브랜치에도 병합한다. 그 후에 릴리스 브랜치는 삭제한다. 

하지만 세상 일이 어찌 자기 마음대로만 되겠는가. 분명 새로운 운영 환경에 릴리스한 후 문제가 생길 수 있을 것이다. 그러면 문제 해결을 위해 master브랜치를 부모로 하는 임시 브랜치를 만든다. 통상적으로 이름은 `hotfix`브랜치 라고 정의하며 오로지 버그 수정만을 위한 브랜치이고 master를 부모로 하기 때문에 다음 릴리스를 위해 개발하던 작업 내용에는 전혀 영향을 주지 않는다. 패치가 준비되면 master와 develop 브랜치 양쪽에 병합하고, 긴급 해치가 완료 되었으므로 애플리케이션 버전 1.1이라는 새로운 버전 이름으로 태그를 매겨야 한다.




릴리스를 위한 전용 브랜치를 사용함으로써 한 팀이 릴리스를 준비하는 동안 다른 팀은 다음 릴리스를 위한 기능 개발을 계속할 수 있다. 즉, 딱딱 끊어지는 개발 단계를 정의하기에 아주 좋다. 예를 들어, 이번 주에 버전 4.0 릴리스를 목표로한다라고 팀 구성원들과 쉽게 소통하고 합의할 수 있다는 말이다.



운영 환경에 릴리스한 후 발견된 긴급 패치는 ‘hotfix’ 브랜치를 이용한다. ‘hotfix’ 브랜치만 master에서 바로 딸 수 있다. 

버그 수정만을 위한 브랜치를 따로 만들었기때문에, 다음 릴리스를 위해 개발하던 작업 내용에 전혀 영향을 주지 않는다. ‘hotfix’ 브랜치는 master 브랜치를 부모로 하는 임시 브랜치라고 생각하면 된다.






master 브랜치 뿐만아니라, 이 워크플로우에서는 두 개의 다른 브랜치도 변경 이력을 유지하기 위해 사용한다. master 브랜치는 릴리스 이력을 관리하기 위해 사용하고, develop 브랜치는 기능 개발을 위한 브랜치들을 병합하기 위해 사용한다. 그래서, master 브랜치는 릴리스 태그를 매기기에 아주 적합하다.

feature branch를 배포하는 방법 중에 하나 
각자 로컬브랜치에서 작업. 
원격에 머지를 해. 
작업한 브랜치를 디벨럽 브랜치라고 만들어서 여기다 머지를해. 
새로운사람이왔어. 클론을받을거면 디벨럽브랜치에서 받아서 개발하고. 
근데 어떤 특정 예전버전에 오류가 있었어. 그럼 릴리즈 브랜치에서  그버전을 갖고와서 
고친다음에 다시 디벨럽 브랜치에서 머지하고 마스터로 하는거지. 

4. forking workflow
기존에는 한레퍼지토리에서 다 떠갖고와서 했다. 최종적으로는 최종레퍼지토리에서 승인이 나야 나갈수잇는거
그래서 이거는 포크떠서 가지고 와서 
근데이거는  내가갖고있는 특장점만 개발을 더 멋잇게하고 원레퍼지토리에 pr을 날림. 
차이점은 그냥 하나를 가지고 나눠서하다가 이거는 
복사(포크)떠가지고 내 레퍼지토리에서 내맘대로 하다가  어떤 기능만 풀리퀘스트를 날릴게. 

